# 代码整洁之道

软件质量，不但依赖于架构以及项目管理，而且与代码质量紧密相关。代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好的基础。良好的软件实践遵循一些规程：专注、镇定和思考。

+ 整理`Seiri`：一般情况下可以简单理解为命名的合理性，通过恰当的命名手段搞清楚事物
+ 整顿`Seiton`：整齐，每段代码都该在希望出现的地方
+ 清除`Seiso`：对于已经遗弃的或者带有注释的代码以及反映过往或期望的无注释代码，及时清除
+ 清洁`Seiketsu`：标准化，指定可沿用的标准或者是代码规范、编码规则等
+ 身美`Shitsuke`：自律，在实践中贯彻这些规程

## 第一章 整洁代码

### 为什么一定会有代码

随着科技的进步，结合目前有关代码相关的书籍本身就滞后于现实，有些人就会认为代码不再是问题，很多代码会有工具自动生成，不需要再通过人工编写，应该更多的关注模型和需求。

我们需要清楚一点，无论技术发展还是代码可以自动生成，我们永远无法完全抛开代码，一般情况下，代码呈现了需求的细节，而在某些层面上，这些细节无法被忽略或抽象。将需求明确到机器可以执行的细节程度，就是编程要做的事情，而这种规约就是代码。

### 什么是糟糕的代码

在实际的项目开发中，无论开发团队及项目规模的大小程度，代码的数量都会随着时间和开发进度增加，只是增加的多少不同。这样就导致了代码结构、引用关系等越来越复杂，对后期的修改、维护等操作带来很大的麻烦，最后导致无法继续开发，这也就到了这个项目的生命周期结束了。

### 代码混乱的代价

+ 有些团队在项目初期进展迅速，但是有一段时间却很慢，每次修改代码都影响其他的代码
+ 花时间保持代码整洁不仅有关效率，还有关生存
+ 程序员遵从不了解混乱风险的经理的意愿，也是不专业的做法
+ 制造混乱无助于赶上期限，混乱知会拖慢，最后错过期限

### 什么是整洁代码

+ 整洁的代码读起来令人愉悦
+ 完善错误处理代码，在细节上花费心思
+ 整洁的代码只做好一件事，糟糕的代码想做很多事情，意图混乱，目的不明确
+ 整洁的代码简单直接，易读易修改，并且在测试之上，没有测试的代码是不干净的

简单代码，依据重要顺序：

+ 能通过所有的测试
+ 没有重复代码
+ 体现系统中的全部设计理念
+ 包含尽量少的实体， 比如：类、方法、函数等

## 第二章 有意义的命名

软件中随处可见命名，变量、函数、参数、类等都涉及到命名的问题。

1. **名副其实**

   一个好的命名，应该可以答复几乎所有的问题，为什么会存在，做什么事情，怎么使用。如果一个命名需要使用注释来补充，那就不算是一个好的命名。

   代码的简洁度和代码的模糊度相比之下，模糊度优先级更高，如果一个命名在阅读之后，很明确他的含义且唯一，就是一个好的命名；相反，如果阅读一个命名之后，含义不明确或者存在多意的可能，那就不是一个很好的命名。

2. **避免误导**

   这里的误导，可以简单理解为不要使用一些关键字作为变量的名称，比如看到`List`，一般情况都会理解为是一个类型或者是一个开发环境/语言已经定义使用的一个词，那在开发过程中就不要使用这个词来命名，这就避免了误导。再有就是字母`I`和数字`1`在很多时候不仔细进行区分是很容易混淆的，那就不要使用这些来命名。

3. **做有意义的区分**

   在命名的时候，不是为了满足编译器和解释器的需求，如果只是这样的话，命名就很随意，可以使用一些完全没有实际意义的字母数字组合来命名，但是这样做就失去了代码的可读性。在满足名副其实的前提下，不要增加一些冗余的修饰性的废话，完全没有意义，能够表明名称的含义和作用，能够区分不同命名之间的区别即可。

4. **使用读的出来的名称**

   在命名的时候不要只是自己认识，有些自造的词不要使用，使用一些常规的、标准的或者是默认的词语来命名

5. **使用可搜索的名称**

   在命名的时候，坚持一个原则就是方便进行搜索，也就是增加该名称和其他名称之间的区别

6. **避免使用编码**

   特定的编码会让后来者不知所云，把类型或作用域编进名称里面，增加了编码的负担

7. **避免思维映射**

   不应当让读者看了名称后翻译成他所熟知的名称，依据一些潜意识的翻译进行错误的理解

8. **类名**

   类名和对象名应当是名词或名词短语

9. **方法名**

   方法名应当是动词或动词短语

10. **别拌可爱**

    不适用幽默词语或者只有自己能懂的词语，言和意要一一对应，很明确

11. **每个概念一个词**

12. **不适用双关语**

13. **使用解决方案领域名称**

    因为读代码的人基本都是当前技术领域内的人员，所以命名的时候尽量使用计算机领域以及项目行业领域内的专业术语

14. **使用源自所涉问题领域的名称**

15. **添加有意义的语境，不添加没用的语境**

## 第三章 函数

在编程中，函数几乎就是程序运行的最小的单位了。如果一个函数很复杂，功能很多，代码行数很多，不只是在阅读的时候费力，在运行过程中出错的概率也增大了很多。

所以在写函数的时候就需要注意一些问题

1. **短小**

   函数的第一规则就是短小，第二规则就是还要更短小。函数不应该有很大的嵌套结构，缩进层级不该多于一层到两层。从复杂度的角度来讲，一般情况下，一个函数的圈复杂度不应该很大，圈复杂度大于10的函数就不是一个清晰的函数，存在很大的出错风险。

2. **只做一件事**

   函数应该做一件事，做好这件事，只做这件事。

3. **每个函数的抽象层级**

   要确保每个函数只做一件事，函数中的语句都要在同一抽象层级。简单理解抽象层级，就是同一类事情。比如：获取数据和处理数据是两个动作，都是数据的操作，可以抽象为操作数据，属于同一抽象层级。但是获取数据的细节和处理数据的细节这两个工作明显和他们不是同一个抽象层级，所以就需要单独抽离成函数，这样才能做到函数只做一件事。

4. **switch语句**

   `switch`天生就是做N件事情的，总是无法避开`switch`语句。我们可以结合策略模式或者工厂模式进行逻辑分离，将语句埋藏在较低的抽象层级，减少重复次数，充分利用多态

5. **使用描述性的名称**

   简单来讲，就是函数应该有一个好名字。函数越短小，功能越集中，就越便于起一个很好的名字。使用一些描述性的名称，哪怕是比较长，也比令人费解的名称好。还有一点，就是命名的方式保持一致，也就是通常理解的侠义上的命名风格

6. **函数参数**

   最理想的函数是零参数的，其次是单参数函数，再次是双参数函数，尽量避免三参数或者更多参数。从测试角度来看，如果参数很多，就直接增加了测试用例的个数，也就是增加了测试的难度，降低了测试覆盖率。

   尽量不要输出参数，相比于输入参数更难理解。

   向函数传入`bool`类型参数会使方法签名立刻变得复杂，这也就表明了函数做的事情不止一件

7. **无副作用**

   函数只做一件事，但还是会做其他被藏起来的事情，会导致古怪的时序性耦合及顺序依赖

8. **分隔指令与询问**

   函数要么做什么事，要么回答什么事，二者不可兼得

9. **使用异常替代返回错误码**

   + 从指令式函数返回错误码轻微违反了指令与询问分隔的规则
   + try-catch代码块把错误处理与正常流程混为一谈，最好把try和catch代码块的主体部分抽离出来
   + 错误处理就是一件事，处理错误的函数不该做其他事情
   + dependency magnet：如果采用返回错误码的形式，就说明在代码的某个地方定义了一个类或者是枚举，声明了这些错误码，并且在使用的地方必须引用这个类或者是枚举，如果这个类或者枚举发生了变更，那就说明使用到错误码的地方都需要进行是否进行修改的检查

10. **别重复自己**

    重复是软件中一切邪恶的根源。许多原则与实践规则都是为了控制与消除重复

## 第四章 注释

注释的恰当用法是弥补我们在用代码表达意图时遇到的失败。其实注释是一种失败，我们在能使用代码表达的情况下，绝不使用注释。

注释不能美化糟糕的代码。带有少量注释的整洁而有表达力的代码，要比有大量注释的零碎而复杂的代码好很多

### **好注释**

+ 法律信息，比如版权信息
+ 提供信息的注释
+ 对意图的解释，提供某个决定背后的意图
+ 阐释，注释某些难懂的参数或返回值的意义，呈现出一种可读易读形式
+ 警示，有时，用于警示出现某种后果的注释
+ TODO注释，程序员认为应该做，但是因为某种原因没有实现，需要定期检查并清除
+ 放大，放大某种看来不合理之处的重要性
+ 公共API

### **坏注释**

+ 喃喃自语，有些时候出于某些原因，作者会写一些自己觉得应该有的注释，但是对于其他读者并没有作用

+ 多余的注释，通过代码能明显看出逻辑的时候，就不需要写注释

+ 误导性注释，有时候注释没有覆盖全部代码逻辑，引起调用人员的误解

+ 循规式注释，有时候，类、函数、变量会要求全部写注释

+ 日志式注释，将代码每次修改的时间、人员、修改的内容以注释的形式记录下来

+ 废话注释，有些注释就是代码名称的复述，纯属废话，更可怕的是写错了的废话

+ 能用函数或变量时就别用注释

  ```java
  // 坏注释
  // does the module from the global list <mod> depend on the
  // subsystem we are part of?
  if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem()))
      
  // 改成没有注释的情况
  ArrayList moduleDependees = smodule.getDependSubsystems();
  String ourSubSystem = subSysMod.getSubSystem();
  if(moduleDependees.contains(ourSubSystem))
  ```

+ 位置标记

+ 括号后面的注释

+ 归属和署名，这种注释类似日志式注释，完全可以使用源代码控制系统来进行管理

+ 注释掉的代码，如果发现一段代码不需要了，尽快删掉，因为可以依赖源代码控制系统找回删掉的代码，以免给后人造成困扰

+ HTML注释

+ 非本地信息注释

+ 注释的作用是解释未能自行解释的代码，如果注释本身还需要解释，就是失败的注释

+ 函数头，短函数不需要太多描述，起一个好的函数名字，比写函数头注释要好很多

## 第五章 格式

代码格式关乎沟通，很重要。

### **垂直格式**

+ 段文件比长文件已于理解
+ 源文件要想报纸文章，名称一目了然，名称本身应该足够说明是否在正确的模块中。源文件自顶部应该给出高层次概念和算法。细节应该往下渐次展开，直到找到文件中最底层的函数和细节
+ 几乎所有的代码都是从上往下读，从左往右读，每行展现一个表达式或一个子句，每组代码行展示一条完整大的思路
+ 紧密相关的代码应该相互靠近
+ 除非有很充分的理由，否则就不要把关系密切的概念放到不同的文件中，实际上避免了在不同的源文件之间相互切换
+ 变量声明应尽可能靠近使用位置
+ 实体变量在类的顶部声明
+ 相关函数，如果某个函数调用了另一个函数，尽可能的放到一起，调用者放到被调用者的上面
+ 概念相关的代码应该放在一起，相关性越强，彼此之间的距离应该越短

### **横向格式**

+ 尽力保持代码行短小，遵守无需拖动滚动条到右边的原则，最好不要超过120个字符，C#规范一般是80个字符
+ 使用空格字符将彼此紧密相关的事物连接到一起，也用空格字符把相关性较弱的事物分开
+ 对齐，像是在强调不重要的东西，把目光从真正意义上拉开
+ 如果有较长的列表需要做对齐处理，那就是更注重列表的长度而不是对齐
+ 依赖缩进模式
+ 空范围，有些时候会遇到无法避免的while或者for语句的空语句体，这个时候使用大括号进行包装，不要只写一个分号

### **团队原则**

​	每个开发人员都有自己特有的代码风格，但都要在团队的规格允许范围内使用自己的特色。好的软件系统是由一些列读起来不错的代码文件组成的，需要拥有一致的和顺畅的风格。

## 第六章 对象和数据结构

### 数据抽象

隐藏实现关乎抽象，类并不简单地用取值器和赋值器将其变量推向外部，而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据本体

### 数据、对象的反对称性

首先搞清楚什么是数据结构，什么是对象

**数据结构**

+ 数据机构是数据在存储时候所展现的一定的结构形式
+ 是两个方法交互的接口或者说是媒介
+ 数据结构是面向问题提出的解决数据处理的结构
+ 数据结构的变更可以提高代码的执行效率，也是算法的基础

**对象**

+ 对象可以包含变量、方法、数据结构

示例

```c#
// 过程式形状代码，面向过程
public class Square
{
    public Point topLeft;
    public double side;
}
public class Rectangle
{
    public Point topLeft;
    public double height;
    public double width;
}
public class Circle
{
    public Point center;
    public double radius;
}
public class Geometry
{
    public const double Pi = 3.14;
    public double Area(Object shape)
    {
        if(shape is Square s)
        {
            return s.side * s.side;
        }
        else if(shape is Rectangle r)
        {
            return r.height * t.width;
        }
        else if(shape is Circle c)
        {
            return c.radius * c.radius * Pi;
        }
        else
        {
            throw;
        }
    }
}
```

```c#
// 多态式形状代码，面向对象
public class Square : Shape
{
    private Point topLeft;
    private double side;
    public double Area()
    {
        return side * side;
    }
}
public class Rectangle : Shape
{
    private Point topLeft;
    private double height;
    private double width;
    public double Area()
    {
        return height * width;
    }
}
public class Circle : Shape
{
    public const double Pi = 3.14;
    private Point center;
    private double radius;
    public double Area()
    {
        return radius * radius * Pi;
    }
}
```

相互比较这两种不同风格的代码，看上去是相互对立的，说明了对象和数据结构之间的二分原理

+ 过程式便于在不动既有数据结构的前提下添加新的函数，意思是在既有的三个形状不发生任何变化的前提之下，在`Geometry`中新增一个函数的方便的，比如增加一个求周长的函数；面向对象的代码则是在既有函数的前提下增加新类，也就是基类`Shape`不发生变化的情况下，增加一个新的形状是方便的。
+ 过程式如果增加一个新的数据结构，则必须修改所有的函数，意思是如果增加一个新的形状，则`Geometry`类中所有的函数必须发生相应的适配；面向对象代码则是如果新增加一个函数，所有的类就必须发生变化，意思是如果基类`Shape`中增加了一个函数，那么所有继承这个基类的子类就必须有具体的实现，也就是所有的类都发生了变化

通过比对，回头看看**对象把数据隐藏于抽象之后，暴露操作数据的函数；数据结构暴露数据，没有提供有意义的函数**，这句话的意思就是面向对象的代码，通常情况公开的是一些有功能的函数，而数据结构则公开的是具体的数据，并不提供操作数据的方法。

### 迪米特法则

也叫做最少知道原则，也就是说，一个对象应当尽可能少的了解其他对象。目的在与降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块独立，相互之间不存在依赖关系。

两个对象之间，如果必须存在依赖关系，尽可能少的使用内部数据或者是其他数据结构，最好是使用方法调用的方式进行依赖

### 数据传送对象

最为精炼的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为**数据传送对象**，Data Transfer Objects 简称DTO。

## 第七章 错误处理

编写代码的过程中，或者是代码中，肯定会存在可能发生异常的位置，关于异常处理的方式有很多中，但是基本都会遵循一些合理的规则

### 原则

错误处理很重要，也是必要的手段，但如果搞乱了代码逻辑，就是错误的做法。

如：很多语言没有异常捕获处理的手段，很多时候都是在发生异常的时候返回一个错误代码或者约定好的手段，那么就必须在逻辑处理过程中经常检查错误，这就导致代码逻辑混乱。

### 常见的规约

1. 遇到错误的时候，最好是抛出一个异常，调用代码很整洁，逻辑不会被错误处理高混乱
2. 先写`try-catch-finally`，在某种意义上，`try`代码块就像是事务，`catch`代码块将程序维持在一种持续状态
3. 使用不可控异常。可以预知的异常，类如从文件中读取数据，对数据库操作等，在程序编译时就能对程序中可能存在的错误进行处理，并给出具体的错误信息。那些不可预知，不能被编译器检测到的，例如在进行运算时的除数为零，试图把一个不是由数字组成的字符串转为数值型等情况被称为不可控异常。
4. 给出异常发生环境说明。针对抛出的异常，最好是给出足够的信息，包括发生异常的环境和条件，或者发生异常是的具体的错误信息，以便于分析错误的来源和处理
5. 根据调用者需要定义异常类。因为错误的种类很多，可以来自各个方面，所以我们在定义异常类的时候，最重要的就是考虑如何捕获这些异常。
6. 定义常规流程。特例模式，创建一个类或配置一个对象，用来处理特例，异常行为被封装在特例对象中，这样就可以使客户代码不需要管理异常
7. 别返回`null`值。返回`null`值容易引发错误，基本上就是在给开发人员增加工作量，同时也使得调用者很麻烦，只要有一处没检查，就有可能出现失控
8. 别传递`null`。将`null`值作为参数也是一个很糟糕的方法。

## 第八章 边界

在一个系统中，一般情况都会分为多个子系统、模块或者其他称呼，不太可能是一个人或者一个小团队就可以完成，基本都会使用到第三方或者团队中其他模块的组件，或者我们自己作为一个组件的提供者，这都需要保持边界整洁，可以嵌入或者被嵌入的时候简单且完整。其实在软件设计的时候遵循的单一职责原则，在这里也可以体现出来，每一个子系统，每一个模块，每一个独立的组件等，只要是相对独立的一块，就应该坚持单一职责，有明显的职责界限。

1. 使用第三方代码。在接口提供者和使用者之间，存在与生俱来的张力。第三方程序包和框架提供者追求普适性，这就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需求的接口。这就会导致系统边界上出现问题。
2. 浏览和学习边界。在接触一个新的第三方模块的时候，不要在生产代码中实验新东西，而是编写测试来遍历和理解第三方代码。这种方式被称为学习性测试，不只是免费无成本，更关键的是通过使用一些测试用例，能够很快摸清楚第三方代码的作用和功能，还不影响现有的生产中的代码逻辑。
3. 使用尚不存在的代码。编写我么想得到的接口，好处之一是它在我们控制下，有助于保持客户代码更可读，且集中于它该完成的工作。
4. 整洁的边界。边界上的改动，有良好的软件设计，无需巨大投入和重写即可进行修改。边界上的代码需要清晰的分割和定义了期望的测试。

## 第九章 单元测试

单元测试，是指对软件中的最小可测试单元进行检查和验证。至于`单元`的大小或范围，并没有明确的标准，可以是一个函数，方法，类，功能模块或者子系统。通常情况下，单元测试和白盒测试会联系到一起。如果只是从概念上来讲是有区别的，不过我们通常所说的这两者都是和代码有关系的，所以一般情况下认为两个是同一个东西，都是对开发人员编写的代码进行测试。

开发人员做单元测试：

+ 优点：开发人员对代码熟悉，而且开发人员编程技能相对较强，从单元测试效率和覆盖率上讲是比较高的
+ 缺点：开发人员平时写业务代码需要花费很多的时间，有时候确实没有时间写测试代码，而且大部分开发人员没有好的测试思维，只是写个简单的测试用力就完了，等同于自己给自己做裁判的意思

测试人员做单元测试：

+ 优点：测试人员有比较系统的测试思维，可以更好地保证用力的覆盖，而且通过写单元测试能更好地了解具体代码结构、流程，对于后续的业务测试也是非常有利的
+ 缺点：测试人员编程技能相对较弱，对代码的熟悉程度相对较低，效率也会比较低

### `TDD`三定律

+ 定律一：在编写不能通过的单元测试之前，不可编写生产代码
+ 定律二：只可编写刚好无法通过的单元测试用例，不能编译也不算通过
+ 定律三：只可编写刚好满足以通过当前失败测试的生产代码

### 保持测试整洁

测试代码和生产代码一样重要，脏测试会让测试越变越糟，维护代价增大。

单元测试带了 很多的好处。覆盖了生产代码的自动化单元测试程序能尽可能地保持设计和架构的整洁。有很多情况，我们修改一些生产代码，但是会担心是否会引入新的不可预知的缺陷，或者是被修改的模块是否影响到所有的调用者的正常使用。单元测试就很好的解决了这个问题，通过测试就可以很好的把这些不可预知变成了可控。一旦涉及到引入新的缺陷，单元测试就会出现不通过的现象，提醒开发人员进行修复。当然，如果单元测试没有做的很好，或者测试用力覆盖的不够，有了单元测试也不会检查出问题。

### 整洁的测试

整洁的测试有一个很重要的要素，那就是可读性。在这方面比起生产代码，有更高的更重要的要求。

一个单元测试方法，基本会遵循一种比较常规的模式。

+ AAA规则：Arrange-Act-Assert,安排-操作-断言
+ BUILD-OPERATE-CHECK:构造-操作-检查

两种模式的思想基本一致，第一步都是在创造一些测试使用的数据，因为没有实际的运行环境，需要自定义或者是伪造一些测试过程中使用到的数据；第二步就是对这些数据进行操作，结合要测试的单元，根据测试用例处理这些测试数据；第三步就是对数据操作之后的结果进行判定，检查结果是否达到预期。

### 每个测试一个断言

单个断言是个很好的准则，但是当一个以上断言的前提条件相同，非要遵循单个断言的准则，就会有重复的代码，所以单个测试中的断言数量应该最小化。所以，我们在写单元测试的时候，每个测试的目标都最好是一个，尽可能减少一个测试中断言的数量

### 整洁的测试遵循的规则

+ 快速 Fast：测试应该快速。因为测试代码可能会频繁运行，如果测试不能很快速进行，就可能导致问题发现不及时等问题
+ 独立 Independent：测试应该相互独立。在同时执行很多测试的时候，测试顺序是随机无序的，但不会并行执行
+ 可重复 Repeatable：测试应该可在任何环境中重复通过。一个测试，应该在任何环境下都能运行通过，不可以设定特殊的运行环境
+ 自足验证 Self-Validating：测试应该由布尔值输出。无论是通过或失败，最好不要依赖人工依赖主观，更多的或者完全的交给测试自足验证
+ 及时 Timely：测试应该及时编写。单元测试应该恰好在使其通过的生产代码之前编写

## 第十章 类

在面向对象编程中，对象一般是具体的一个实例，有静态特征和动态特征，外观、性质、属性等静态特征，对象具有的功能和行为称为动态特征。将有相同属性的相同行为的一组对象抽象称为一个类，广义地讲，具有共同性质的事物的集合就被称为类。

所以类是编程中一个很重要的概念，自然也就对类有一些要求，不能随便写一个类。

### 类的要求

类应该短小

1. 单一权责原则
2. 内聚
3. 开放-闭合原则：对扩展开放，对修改封闭

***这里可以参照设计模式中规定的7个设计原则***

## 总结

综合正本书籍的阅读，提供了一些新的编程思路和要求，对于一个初学者可能不太适合，但是作为一个编程人员，最好还是遵守一些基本的规约，能够好的写出稳定的整洁的代码。后面几章内容对于编程语言`Java`的依赖性比较强，暂时不做参考，可能一个`Java`开发人员比较适用。

# 框架设计指南

构建可复用`.NET`库的约定、惯例与模式

## 导论

既然是框架设计指南，肯定要搞清楚什么是框架，框架到底指的是什么。作为一个程序员，肯定或多或少都会接触到框架这个词，在平时开发过程中，大部分时间和精力都在业务代码上，所以，除了专业做框架设计开发的从业者，其余的程序员几乎都是作为框架的使用者。

在最开始的时候，还没有框架的产生，也就是计算机初期，开发应用的主要工具就是语言编译器，一个很小的标准库集合和操作系统应用编程的原始接口`API`，这是一套非常基础的编程工具集。在这种条件下进行应用开发，可想而知，肯定会有很多的代码是重复的，因为没有将其进行抽象或者封装，即使是各自进行抽象和封装，那么也会存在因人而异的情况，毕竟每个人进行抽象和封装的时候往往考虑的是如何结合目前的产品或者更方便自己使用，这就还是不能拜托代码重复的情况。所以在这种情况下，操作系统就有责任和义务，更有商机，将更多的代码进行抽象，以`API`的形式开放给用户，这样`API`越来越多，很多重复代码被抽象，使用者越来越方便，开发成本也越来越低，那么就会导致更多的应用出现。

在这个时期，面向对象编程也出现并被越来越多的人接受，毕竟在可复用性和可扩展性方面确实有其重要性。这个时候就产生了所谓的**框架**。也就是说，开发应用的编程人员不用再从无到有开发应用，框架为其提供了大部分所需的代码，然后开发者只需要按照需求进行自定义和连接就可以形成应用。

### 设计精良的框架的特质

+ 设计精良的框架是简单的

  框架是服务开发人员的，而不是限制开发人员的。很多的框架具有太多的能力，随着需求的不断增加和版本的迭代，具备的功能也会随着时间越来越完善。如果准备新增加一个功能，但是发现设计上很复杂，那么最好的做法就是把这个功能从发布版本移除，在下次发布前花更多的时间做正确的设计。

+ 设计精良的框架设计成本高昂

+ 设计精良的框架充满权衡

+ 设计精良的框架会借鉴过往经验

+ 设计精良的框架旨在不断发展

+ 设计精良的框架是完整统一的

+ 设计精良的框架是一致的

## 框架设计基础

一个成功的框架，在设计时就一定要考虑到有着不同需求，技能和背景的开发者。

框架设计者的一个巨大挑战是：既满足多样化的用户群体的功能需求，又要保持框架本身的简单性

框架设计者的另一个重要目标是提供同一的编程模型

+ 功能强大且易于使用的框架
+ 面向不同的编程风格、需求和技能水平的开发者
+ 面向不同的开发语言

### 渐进式框架

既然是框架，仍然坚持是方便开发者的原则，无论框架提供多少功能，都不能出现对开发者已有知识和能力的断层是需求。如果将使用框架需要具备的能力和使用框架的各个部分绘制一个曲线图形，那么最好是一个平滑的曲线，而不是拥有台阶的曲线。

同一个框架，不同程度的开发者使用框架的难易程度肯定会存在差异，因为不是所有的开发者都有相同的水平。所以，这就要求框架对开发者的要求不能有断层式的学习曲线，而最好是提供比较平滑的缓慢上升的要求。



### 框架设计的基本原则

1. 场景驱动设计原则

   框架设计必须从一组使用场景和实现这些场景的代码示例开始

   + 要确保`API`设计规范是任何功能设计的核心

   + 要为主要功能领域定义主要使用场景
   + 要确保场景切合适当的抽象水平
   + 要为主要场景编写代码示例
   + 要至少两种不同的语言来编写主要场景代码示例
   + 建议使用动态类型语言来编写主要场景代码示例
   + 不要只依赖于标准设计方法

2. 低门槛原则

3. 对象模型自文档化原则

4. 分层架构原则
